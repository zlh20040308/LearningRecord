# 第六章 RVOS介绍  

## RTOS  

### FreeRTOS  

### RT-Thread  

## RVOS  

用于教学演示的操作系统内核  

- 演示简单的内存分配管理  
- 演示可抢占多线程调度实现，线程调度采用轮转调度法  
- 演示简单的的任务互斥实现  

# 第七章 HELLO RVOS  

## 系统引导过程  

### 硬件基础  

- Hart  

    在RISC-V领域就是一个处理器的概念，里面有ALU、寄存器以及控制单元  

- IO  

    输入输出设备

- BUS  

    总线  

- DRAM  

    掉电之后内容不在的内存  

- RAM  

    掉电之后内容还在的内存  

- Platform  

    把上面的东西全都包起来

### 系统引导过程  

#### QEMY-virt 地址映射  

为了便于操作处理器、控制器等外设中的寄存器，将所有的外设进行统一编制，也就是每一个外设都对应一段地址范围，要注意这些地址都是物理地址，通过访问对应地址的内存来控制对应的元器件  

#### 系统引导过程介绍  

CPU在开始运行的时候会先来到0x00001000处，对应的就是ROM的起始位置，在这里放着一些指令，我们把这些指令叫做Bootloader，他负责初期的一些准备工作，比如说将Kernel加载到DRAM里面等，但是我们的软件模拟器并没有做这么多事情，我们要自己手动添加命令行参数来指定Kernel代码在哪个文件里面：  

![替代文本](/risc-v_pic/start_qemu.png)  

在编译Kernel代码的时候，也要加上命令行参数来告诉链接器要将编译好的代码放在内存的哪个地方：  

![替代文本](/risc-v_pic/generate_kernel.png)  

### 引导程序要做什么事  

qemu实际上可以跑多个核，但是这样就会导致我们的引导程序会被每个核都执行一遍，我们要做的是它只跑一个核  

实现方法就是让除了第一个核的其他核在执行到引导程序的时候进行空转，当该核发现自己不是第一个核，就进入空转  

#### 如何判断当前核是不是第一个核？  

##### Control and Status Registers (CSRs)  

![替代文本](/risc-v_pic/level.png)  

- 除了所有level下都可以访问的寄存器之外，每个level都有自己对应的一组寄存器  
- 高level可以访问低level的CSR，反之不可以  
- ISA Specification 定义了特殊的CSR指令来访问这些CSR

###### Machine模式下的CSR  

我们来认识一下Machine模式下的CSR，因为在qemu启动(上电)之后，CPU默认就运行在Machine模式下

- CSR指令  

    - CSRRW （Atomic Read/Write CSR）  
    格式：CSRRW RD CSR RS1  
        - 先读出CSR中的值，将其按XLEN位的宽度进行零扩展后写入RD；然后将RS1中的值写入CSR  
        - 以上两步操作以“原子性”方式完成  
        - 如果RD是X0，则不对CSR执行读的操作  

    - CSRRS （Atomic Read and Set Bits in CSR）  
    格式：CSRRW RD CSR RS1  
        - 先读出CSR中的值，将其按XLEN位的宽度进行零扩展后写入RD；然后逐个检查RS1中的值，如果某一位为1则对CSR的对应位置1，否则保持不变  
        - 以上两步操作以“原子性”方式完成  
 
##### mhartid  

- 该 CSR 只读  

- 包含了运行当前指令的 hart ID  

- 第一个 hart ID 为 0  

##### 实现流程  

1. 在每个 hart 一开始执行引导程序时，先执行 csrr 指令将 mhartid 中的值读出来  
2. 判断该值是否为 0 ，如果是，则正常跳转至Kernel，如果不是，则执行 wfi（Wait for Interrupt Instruction）休眠  

#### 如何跳转到 C 语言的执行环境  

因为接下来基本上编写的都是C语言代码，所以要稍微了解一下汇编和C是怎样一起工作的，其实把C语言中的函数看成汇编里的函数的话，函数名就是标签，在汇编中调用C函数只需要call相应的C语言函数名就行了  

## "Hello, RVOS! "  

在开发一个系统的时候，假设我们要看程序的运行情况的话，我们通常会希望用打印的方法来看看系统日志，那么这个板子的话，其实我们一开始我们并没有一个合适的手段去打印这个东西，我们怎么样去把我们这个东西给打印出来呢，这实际上是利用了板子上的串口设备

### UART 的硬件连接方式  

![替代文本](/risc-v_pic/develop_env.png)  

这张图展示了嵌入式开发的一般情况（交叉开发环境）：  

- 在主机上进行开发  
- 程序跑在开发板上  

实验里面用的是开发板模拟器，但差别不大  

我们可以看到开发板并没有集成显示器，没有办法将信息打印到所谓的“屏幕”上，但是我们主机上是有屏幕的，所以可以通过一根串口线将开发板与PC相连接，这样，开发板就可以使用PC的显示器来打印信息了  

### UART 的特点  

### UART 的通信协议  

- 空闲位：总线处于空闲状态的时候，信号线的状态为“1”，即高电平  
- 起始位：发送方要先发出一个低电平“0”，来表示传输字符的开始
    - 当要开始传输数据的时候，先从高电平变成低电平，持续一个比特的时间，以此来告诉接收方接下来要开始传数据了
- 数据位：起始位之后就是要传输的数据，数据长度（word length）可以是 5/6/7/8/9 位，构成一个字符，一般都是8位。先发送最低位最后发送最高位。
- 奇偶校验位（parity）：串口校验分几种方式：
    - 无校验 (no parity)  
    - 奇校验（odd parity）：如果数据位中'1'的数目是偶数，则校验位为'1'，如果'1'的数目是奇数，校验位为'0'  
    - 偶校验（even parity）：如果数据为中'1'的数目是偶数，则校验位为'O'，如果为奇数，校验位为'1'  
    - mark parity：校验位始终为1  
    - space parity：校验位始终为0  
- 停止（stop）位：数据结束标志，可以是1位，1.5位，2位的高电平。  

### NS16550a 编程接口介绍  

NS165500a实际上qemu模拟器所模拟的一款串口收发器的一个型号，这个型号是一个真实的型号，是一款比较通用的串口收发器  

那么接下来我们就来看一下具体编程的时候到底是怎么去操作这个东西了  

要操作一个外部设备，所谓的对接口设备进行编程，其实就是去控制它里面的一些寄存器，但与CPU上的通用寄存器不同的是，我们不能通过名字来访问这些外设内部的寄存器，那要怎么访问这些寄存器呢，做法和上面一样，我们将这些寄存器的地址通过内存映射的方法在内存中分配一块区间，对这些寄存器进行统一编址  

注意：URAT上的每个寄存器都是 8 位的

### NS16550a 的初始化  

所谓的初始化其实就是要去设置像波特率、校验位之类的东西，这样设备才能够正常的工作，这是必须要做的  

对应到代码上就是这个样子：  

![替代文本](/risc-v_pic/uart_init.png)  

这个函数会在我们启动的过程中被调用  

在函数内的第一行，我们首先把是这个设备的中断功能给禁掉了，现在暂时用不上  

接下来四行实际上就是在设置这个串口的波特率，也就是收发的速率  

接下来在设置一些校验位  

# 第八章 内存管理  

