# 第六章 RVOS介绍  

## RTOS  

### FreeRTOS  

### RT-Thread  

## RVOS  

用于教学演示的操作系统内核  

- 演示简单的内存分配管理  
- 演示可抢占多线程调度实现，线程调度采用轮转调度法  
- 演示简单的的任务互斥实现  

# 第七章 HELLO RVOS  

## 系统引导过程  

### 硬件基础  

- Hart  

    在RISC-V领域就是一个处理器的概念，里面有ALU、寄存器以及控制单元  

- IO  

    输入输出设备

- BUS  

    总线  

- DRAM  

    掉电之后内容不在的内存  

- RAM  

    掉电之后内容还在的内存  

- Platform  

    把上面的东西全都包起来

### 系统引导过程  

#### QEMY-virt 地址映射  

为了便于操作处理器、控制器等外设中的寄存器，将所有的外设进行统一编制，也就是每一个外设都对应一段地址范围，要注意这些地址都是物理地址，通过访问对应地址的内存来控制对应的元器件  

#### 系统引导过程介绍  

CPU在开始运行的时候会先来到0x00001000处，对应的就是ROM的起始位置，在这里放着一些指令，我们把这些指令叫做Bootloader，他负责初期的一些准备工作，比如说将Kernel加载到DRAM里面等，但是我们的软件模拟器并没有做这么多事情，我们要自己手动添加命令行参数来指定Kernel代码在哪个文件里面：  

![替代文本](/risc-v_pic/start_qemu.png)  

在编译Kernel代码的时候，也要加上命令行参数来告诉链接器要将编译好的代码放在内存的哪个地方：  

![替代文本](/risc-v_pic/generate_kernel.png)  

### 引导程序要做什么事  

qemu实际上可以跑多个核，但是这样就会导致我们的引导程序会被每个核都执行一遍，我们要做的是它只跑一个核  

实现方法就是让除了第一个核的其他核在执行到引导程序的时候进行空转，当该核发现自己不是第一个核，就进入空转  

#### 如何判断当前核是不是第一个核？  

##### Control and Status Registers (CSRs)  

![替代文本](/risc-v_pic/level.png)  

- 除了所有level下都可以访问的寄存器之外，每个level都有自己对应的一组寄存器  
- 高level可以访问低level的CSR，反之不可以  
- ISA Specification 定义了特殊的CSR指令来访问这些CSR

###### Machine模式下的CSR  

我们来认识一下Machine模式下的CSR，因为在qemu启动(上电)之后，CPU默认就运行在Machine模式下

- CSR指令  

    - CSRRW （Atomic Read/Write CSR）  
    格式：CSRRW RD CSR RS1  
        - 先读出CSR中的值，将其按XLEN位的宽度进行零扩展后写入RD；然后将RS1中的值写入CSR  
        - 以上两步操作以“原子性”方式完成  
        - 如果RD是X0，则不对CSR执行读的操作  

    - CSRRS （Atomic Read and Set Bits in CSR）  
    格式：CSRRW RD CSR RS1  
        - 先读出CSR中的值，将其按XLEN位的宽度进行零扩展后写入RD；然后逐个检查RS1中的值，如果某一位为1则对CSR的对应位置1，否则保持不变  
        - 以上两步操作以“原子性”方式完成  
 
##### mhartid  

- 该 CSR 只读  

- 包含了运行当前指令的 hart ID  

- 第一个 hart ID 为 0  

##### 实现流程  

1. 在每个 hart 一开始执行引导程序时，先执行 csrr 指令将 mhartid 中的值读出来  
2. 判断该值是否为 0 ，如果是，则正常跳转至Kernel，如果不是，则执行 wfi（Wait for Interrupt Instruction）休眠  

#### 如何跳转到 C 语言的执行环境  

因为接下来基本上编写的都是C语言代码，所以要稍微了解一下汇编和C是怎样一起工作的，其实把C语言中的函数看成汇编里的函数的话，函数名就是标签，在汇编中调用C函数只需要call相应的C语言函数名就行了  

## "Hello, RVOS! "  

在开发一个系统的时候，假设我们要看程序的运行情况的话，我们通常会希望用打印的方法来看看系统日志，那么这个板子的话，其实我们一开始我们并没有一个合适的手段去打印这个东西，我们怎么样去把我们这个东西给打印出来呢，这实际上是利用了板子上的串口设备

### UART 的硬件连接方式  

![替代文本](/risc-v_pic/develop_env.png)  

这张图展示了嵌入式开发的一般情况（交叉开发环境）：  

- 在主机上进行开发  
- 程序跑在开发板上  

实验里面用的是开发板模拟器，但差别不大  

我们可以看到开发板并没有集成显示器，没有办法将信息打印到所谓的“屏幕”上，但是我们主机上是有屏幕的，所以可以通过一根串口线将开发板与PC相连接，这样，开发板就可以使用PC的显示器来打印信息了  

### UART 的特点  

### UART 的通信协议  

- 空闲位：总线处于空闲状态的时候，信号线的状态为“1”，即高电平  
- 起始位：发送方要先发出一个低电平“0”，来表示传输字符的开始
    - 当要开始传输数据的时候，先从高电平变成低电平，持续一个比特的时间，以此来告诉接收方接下来要开始传数据了
- 数据位：起始位之后就是要传输的数据，数据长度（word length）可以是 5/6/7/8/9 位，构成一个字符，一般都是8位。先发送最低位最后发送最高位。
- 奇偶校验位（parity）：串口校验分几种方式：
    - 无校验 (no parity)  
    - 奇校验（odd parity）：如果数据位中'1'的数目是偶数，则校验位为'1'，如果'1'的数目是奇数，校验位为'0'  
    - 偶校验（even parity）：如果数据为中'1'的数目是偶数，则校验位为'O'，如果为奇数，校验位为'1'  
    - mark parity：校验位始终为1  
    - space parity：校验位始终为0  
- 停止（stop）位：数据结束标志，可以是1位，1.5位，2位的高电平。  

### NS16550a 编程接口介绍  

NS165500a实际上qemu模拟器所模拟的一款串口收发器的一个型号，这个型号是一个真实的型号，是一款比较通用的串口收发器  

那么接下来我们就来看一下具体编程的时候到底是怎么去操作这个东西了  

要操作一个外部设备，所谓的对接口设备进行编程，其实就是去控制它里面的一些寄存器，但与CPU上的通用寄存器不同的是，我们不能通过名字来访问这些外设内部的寄存器，那要怎么访问这些寄存器呢，做法和上面一样，我们将这些寄存器的地址通过内存映射的方法在内存中分配一块区间，对这些寄存器进行统一编址  

注意：URAT上的每个寄存器都是 8 位的

### NS16550a 的初始化  

所谓的初始化其实就是要去设置像波特率、校验位之类的东西，这样设备才能够正常的工作，这是必须要做的  

对应到代码上就是这个样子：  

![替代文本](/risc-v_pic/uart_init.png)  

这个函数会在我们启动的过程中被调用  

在函数内的第一行，我们首先把是这个设备的中断功能给禁掉了，现在暂时用不上  

接下来四行实际上就是在设置这个串口的波特率，也就是收发的速率  

接下来在设置一些校验位  

# 第八章 内存管理  

## 内存的动态分配和释放  

内存映射表：  

![替代文本](/risc-v_pic/memmap.png)  







## 实现 Page 级别的内存分配和释放  





# 第九章 上下文切换和协作式多任务  

## 多任务与上下文  

### 任务的概念  

简单理解的话就是一系列函数栈的执行过程  

### 多任务的概念  

- 多核：多个执行流在不同的核上并行执行    

- 单核：多个执行流在同一个核上并发执行  

### 任务上下文的概念  

就是一系列与该执行流有关的寄存器  

![替代文本](/risc-v_pic/context.png)  

## 协作式多任务的设计与实现  

### 协作式多任务和抢占式多任务  

- 协作式多任务 (Cooperative Multitasking)：协作式环境下，下一个任务被调度的前提是当前任务主动放弃处理器。  
    - 问题：主动放弃意味着程序员要自己在代码中加入放弃CPU使用权的逻辑，也就意味着如果出现了诸如程序员忘记加入放弃逻辑代码或者是程序陷入死循环等情况的话，程序将无法让出CPU的使用权  

- 抢占式多任务 (Preemptive Multitasking)：抢占式环境下，操作系统完全决定任务调度方案，操作系统可以剥夺当前任务对处理器的使用，将处理器提供给其它任务。  

### 协作式多任务的设计思路  

协作式多任务的实现需要我们自己在代码中加入一些指令来让当前程序主动放弃CPU，我们把这步操作称为switch_to，体现在代码中就是一段函数，我们要在自己的代码中主动地调用这个函数  

![替代文本](/risc-v_pic/task.png)  

#### switch_to  

在这个过程中我们最主要的任务就是保存原任务的上下文和复原接下来要调度的任务的上下文  

这里涉及到两个重要的寄存器：  

- ra：  



- mscratch：  



### 协作式多任务的关键实现  


# 第十章 Trap 和 Exception  

## mtvec (Machine Trap-Vector Base-Address)  

![替代文本](/risc-v_pic/mtvec.png)  

- BASE：trap 入口函数的基地址，必须保证四字节对齐。  
当在执行过程中发生异常或者是中断的时候的话，执行流会跳到一个特殊的处理函数的地方（trap 函数），这种函数的位置实际上是可以自己去定制的，那么我们怎么告诉CPU这个函数的基地址在什么地方呢，实际上就是填到这个地方去就可以了  

> 为什么要四字节对齐？  
> 从上图中我们不难看出我们只用了 30 位来表示基地址，那么我们在寻址的时候默认是后两位是 0 （一共32位）。那么这样子规定后我们的地址就一定是四的倍数了。  

- MODE：进一步用于控制入口函数的地址配置方式：  
    - Direct:所有的exception和interrupt发生后PC都跳转到BASE指定的地址处  
    - Vectored:exception处理方式同Direct；但interrupt的入口地址以数组方式排列。  


## mepc (Machine Exception Program Counter)  

![替代文本](/risc-v_pic/mepc.png)  

- 当trap发生时，pc会被替换为mtvec设定的地址，同时hart会设置mepc为当前指令或者下一条指令的地址，当我们需要退出trap时可以调用特殊的mret指令，该指令会将mepc中的值恢复到pc中（实现返回的效果）  
- 在处理trap的程序中我们可以修改mepc的值达到改变mret返回地址的目的。  

## mcause (Machine Cause)  

![替代文本](/risc-v_pic/mcause.png)  

- 当trap发生时，hart会设置该寄存器通知我们trap发生的原因。  
- 最高位Interrupt为1时标识了当前trap为interrupt,否则是exception。  
- 剩余的ExceptionCode用于标识具体的interrupt或者exception的种类。  

## mtval (Machine Trap Value)  

![替代文本](/risc-v_pic/mtval.png)  

- 当trap发生时，除了通过mcause可以获取exception的种类code值外，hart还提供了mtval来提供exception的其他信息来辅助我们执行更进一步的操作。  
- 具体的辅助信息由特定的硬件实现定义，RISC-V规范没有定义具体的值。但规范定义了一些行为，譬如访问地址出错时的地址信息、或者执行非法指令时的指令本身等。  

## mstatus (Machine Status)  






# 第十一章 外部设备中断  

## RISC-V 中断 (lnterrupt) 的分类  

- 本地(Local)中断  
    - software interrupt  
    - timer interrupt  
- 全局 (Global) 中断 externel interrupt  




## RISC-V 中断编程中涉及的寄存器  

### 寄存器 mie、mip  

在RISC-V架构中，mie寄存器是Machine Interrupt Enable Register的缩写。这个寄存器用于控制机器模式下的中断使能。在RISC-V处理器中，中断是一种重要的机制，用于处理外部事件，例如外部设备发出的信号或者其他处理器内部的事件。

mie寄存器中的每一位都对应着一个特定的中断类型。当相应的位被置位时，表示允许相应类型的中断被处理器响应。通常，这些中断类型包括外部中断、定时器中断、软件中断等。通过设置mie寄存器，可以灵活地控制哪些中断类型被允许在机器模式下被处理器响应。

例如，如果某个系统希望在机器模式下允许定时器中断和外部中断，但不允许软件中断，那么可以设置mie寄存器的相应位来达到这个目的。

需要注意的是，mie寄存器仅影响机器模式下的中断使能，而不影响其他模式（如用户模式、超级用户模式）下的中断使能。

## RISC-V 中断处理流程  
## PLIC介绍  
## 采用中断方式从 UART 实现输入
