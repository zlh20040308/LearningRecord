# LearningRecord

这是我参加2024春夏季开源操作系统训练营的学习文档

## Toc

*四月*
* [Day   1    (2024-04-12)](#0)  
* [Day   2    (2024-04-13)](#1)   

<span id="0"></span>
## Day 1

### 计划

   1.阅读《Rust语言圣经》和《Rust程序设计语言》巩固所有权和生命周期的概念       
   2.写rustings
   3.用Rust写leetcode  

### 成果 

   1.完成了对知识点的巩固，Rust在内存回收的机制上比C/C++（手动管理）更暴力--出了作用域不管是在栈上还是在堆上的内存一律回收，比Java（GC）更高效--得益于Rust的检查机制，内存回收策略更简单（暴力）
   2.除了剩余的10道algorithm，其余部分全部完成  
   3.还没开始刷，发现迭代器和闭包学得不够扎实，还是不太熟悉Rust这门语言

### 待解决的问题

### 感想与总结


<span id="1"></span>
## Day 2

### 计划

   1.跟进《RISC-V上的操作系统 - 汪辰 - 2021春》，做lab
   2.阅读《Rust编程之道》第三章类型系统
   3.写rustings

### 成果

   1.RISC-V调试指令
   ```shell
   #一律都要做的
   cd ~/asm/<practice>
   make
   #查看指令的十六进制形式
   make hex
   #反汇编
   make code
   #退出反汇编
   q
   #运行代码
   make debug
   #退出gdb
   Ctrl-C
   quit
   y
   #单步调试（single instruction）
   si
   #重复上一次的命令
   直接回车
   ```
   2.阅读笔记
   - 字符串类型：
     - &str 由两部分组成：指针和长度信息，存储于栈上
     - str字符串序列存储于堆上
     - 包含了动态大小类型地址信息和携带了长度信息的指针，叫作胖指针（Fat Pointer），所以&str是一种胖指针
     - 这里我不是很理解的一句话是“对于编译器来说，str类型的大小是无法确定的”，但是后来我解决了，具体参考[这篇文章](https://zhuanlan.zhihu.com/p/597405802)，简单来就是要分清楚类型大小和值大小的区别。比如说：
      ```cpp
      char a = 1;//那么此时a的类型大小是一字节，但是值大小是1
      ```
     - 同样的，对于str来说：
      ```rust
      let other: &str = "other_hello";//你不能脱离"other_hello"去谈str的类型大小
      ```
     - 再举个例子加深印象，假设有人问你u32的大小，你可以很确定地说是四字节，但是有人问你str的大小时，你是答不上来的，对于编译器也是如此，这取决于字符串序列的大小 

   - 整数类型：
     - 在用Rust编程的时候，应尽量显式声明类型，这样可以避免一些麻烦
   - 孤儿规则（Orphan Rule）
     - 孤儿规则规定，如果要实现某个trait，那么该trait和要实现该trait的那个类型至少有一个要在当前crate中定义。在代码清单3-28中，Add trait和u32、u64都不是在当前crate中定义的，而是定义于标准库中的。如果没有孤儿规则的限制，标准库中u32类型的加法行为就会被破坏性地改写，导致所有使用u32类型的crate可能产生难以预料的Bug。
      ```rust
      代码清单3-28：尝试重载整数的加法操作
      use std::ops::Add;

      impl Add<u64> for u32 {
          type Output = u64;

          fn add(self, other: u64) -> Self::Output {
              (self as u64) + other
          }
      }

      fn main() {
          let a = 1u32;
          let b = 2u64;
          assert_eq!(a + b, 3);
      }
      ```
   3.今天没写rustings，《Rust编程之道》坏（我）我（太）好（菜）事（了）  
### 待解决的问题  

   1. trait对象和动态分发不是很理解，by the way，《Rust编程之道》这本书的编排方式很劝退，按顺序读下去是个错误，起码不是我现在能读得下去的书，太浪费时间了，还是乖乖去看《Rust程序设计语言》罢（悲）  

### 感想与总结
   1.Rust基本过了一遍了，明天开始二刷《Rust程序设计语言》  
   2.RISC-V的学习优先级要提高，之前学过Mips，这个也该不会太难
